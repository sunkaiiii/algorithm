//JS当中的正则表达式
//我对正则其实是不太熟悉的……
//正则表达式是匹配字符串的一种强力的武器
//他的设计思想是用一种描述性语言定义一个规则
//凡是符合这个规则的字符串，我们就认为他匹配了。
//否则这个字符串就是不合法的。

//来了解一下匹配规则
//如果直接给出字符，就是精确匹配
//\d可以匹配一个数字，\w可以匹配一个字母或者数字
//所以
// '00\d'可以匹配'007'，但无法匹配'00A'
// '\d\d\d'可以匹配'010'
// '\w\w'可以匹配'js'
// .可以匹配任意字符，所以
//'js.' 可以匹配'jsp'、'jss'等等
//要匹配变长字符在正则表达式中
// *代表任意个字符（包括0个），用+表示至少一个字符，用？表示0或者1个字符，用{n}表示n个字符，用{n,m}表示n-m个字符
//例子：\d{3}\s+\d{3,8} 即匹配前三个数字且至少一个空格或者\t并且以3-8个数字作为结尾，所以010 88994444是合法的，这个可以用来匹配电话号码
//如果要匹配'-'，由于'-'是特殊字符，需要经过转义，\d{3}\-\d{3,8}

//进阶
//如果要进行更精确的匹配，则可以用[]表示范围
//[0-9a-zA-z\_]可以匹配一个数字、字母或者下划线
//[0-9a-zA-Z\_]+可以匹配至少一个由数字、字母、下划线组成的字符串，比如'a100','0_Z'
//[a-zA-Z\_\$][0-9a-zA-Z\_\$]*可以匹配由字母或下划线、$开头，后接任意一个由一个数字、字母或下划线、$组成的字符串，也就是JavaScript允许的变量名
//[a-zA-Z\_\$][0-9a-zA-Z\_\$]{0,19}更精确的限制了变量的长度是1-20个字符（前面一个字符+后面最多19个字符）
// A|B可以匹配A或B，所以(J|j)ava(S|s)cript 可以匹配'JavaScript'、'Javascript'、'javaScript'或者'javascript'。
// ^表示行的开头，^\d表示必须以数字开头
// $表示行的结束，\d$表示必须以数字结束
// js也可以匹配'jsp'，但是加上^js$就变成了整行匹配，就只能匹配'js'了

//接下来就要在JS当中使用正则表达式了
//JS有两种方式创建正则表达式
//第一种是直接通过/正则表达式/写出来
//第二种是通过new RegExp('正则表达式')创建RegExp
//两种写法一样的
var re1=/ABC\-001/;
var re2=new RegExp('ABC\\-001');
re1;
re2;//如果使用2的写法，因为字符串转义的问题，字符串的\\实际上是一个\
var re=/^\d{3}\-\d{3,8}$/;
re.test('010-12345');//true
re.test('010-1234x');///false
re.test('010 12345');// false

//切分字符串
//用正则表达式切分字符串比用固定的字符更加灵活
'a b   c'.split(' '); // ['a', 'b', '', '', 'c']
//普通方法无法识别连续的空格
//使用正则表达式
'a b   c'.split(/\s+/); //['a','b','c']
//还可以有更多精彩的变化
'a,b, c  d'.split(/[\s\,]+/);
'a,b;; c  d'.split(/[\s\,\;]+/);

//分组
//除了简单地判断是否匹配之外，正则表达式还有提取字串地强大功能
//用（）表示的就是要提取的分组功能
//^(\d{3})-(\d{3,8})$ 分别定义了两个组，可以直接从匹配的字符串提取出区号和本地号码
var re=/^(\d{3})-(\d{3,8}$)/;
re.exec('010-1345');//['010-12345', '010', '12345']
re.exec('010 12345');// null
//如果正则表达式中定义了组，就可以在RegExp对象上用exec()方法提取出字串来
//exec()方法在匹配成功后，就会返回一个array，第一个元素是正则表达式匹配到的整个字符串，后面就是匹配成功的字符串
//在看一个更为凶残的例子
var re=/^(0[0-9]|1[0-9]|2[0-3]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])\:(0[0-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-9]|[0-9])$/;
re.exec('19:05:30');

//贪婪匹配
//需要特别指出的是，正则匹配默认是贪婪匹配，也就是尽可能多的匹配字符
var re=/^(\d+)(0*)$/;//匹配以0结尾地
re.exec('102300'); ['102300', '102300', '']
//由于采用贪婪匹配，直接把后面的0全部匹配了，结果0*只能匹配空字符串了
//必须让\d+采用非贪婪匹配，才能把后面的0匹配出来，加个?就可以让\d+采用非贪婪匹配
var re=/^(\d+?)(0*)$/;
re.exec('102300');//['102300', '1023', '00']

//全局搜索
//JavaScript的正则表达式还有几个特殊的标志
//最常用的就是g，表示全局匹配
var r1=/test/g;
//等价于var r2=new RegExp('test','g');
//全局匹配可以多次执行exec()方法来搜索一个匹配的字符串。
//当我们指定g标志后，每次运行exec()，正则表达式本身会更新lastIndex属性，表示上次匹配到的最后索引
var s = 'JavaScript, VBScript, JScript and ECMAScript';
var re=/[a-zA-Z]+Script/g;//['JavaScript']
re.lastIndex; //10
re.exec(s);//['VBScript']
re.lastIndex;//20;
re.exec(s); // ['JScript']
re.lastIndex; // 29
re.exec(s); // ['ECMAScript']
re.lastIndex; // 44
re.exec(s); // null，直到结束仍没有匹配到
//全局匹配类似搜索，所以因此不能使用/^...$s/,那样最后最多匹配一次
//正则表达式还可以指定i标志，表示忽略大小写，m标志表示执行多行匹配。

//请尝试写一个验证Email地址的正则表达式。
//    should_pass = ['someone@gmail.com', 'bill.gates@microsoft.com', 'tom@voyager.org', 'bob2015@163.com'],
    // should_fail = ['test#gmail.com', 'bill@microsoft', 'bill%gates@ms.com', '@voyager.org'];
var re=/^\w+\.?\w+\@\w+\.\w+/;
//带有名字的
// '<Tom Paris> tom@voyager.org'
var re=/^\<(\w+\s?\w+)\>\s?(\w+\.?\w+@\w+\.\w+)$/;